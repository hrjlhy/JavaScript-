JavaScript课堂笔记

1.5 11:34
要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符：
第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；
第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。
由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。

1.5 11:35
1 / 3 === (1 - 2 / 3); // false
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：

1.5 12:44
var arr = [1, 2, 3];
arr[5] = 'x';
arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。

1.5 12:48
发现各种操作数组的函数- -!
var name='asd';
alert('欢迎 ${name}同学!');
var name='asd';
alert(`欢迎 ${name}同学!`);

1.5 14:47
ES6新增：
Map增加查找速度数组
Set无重复数组
for...of代替for...in

1.5 14:58
由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：
abs(10, 'blablabla'); // 返回10
abs(-9, 'haha', 'hehe', null); // 返回9
传入的参数比定义的少也没有问题：
abs(); // 返回NaN

1.5 18:07
arguments函数内部数组
world(a, b, ...rest)
rest剩余函数

1.6 10:04
JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：
'use strict';
function foo() {
    var x = 'Hello, ' + y;
    alert(x);
    var y = 'Bob';
}
foo();//不会报错

1.6 10:13
域
window.XX函数作用于全局，相当于XX函数
name.XX函数相当于自己定义了一个函数，并且相比于直接定义XX函数，这样做会减少之后调用时的冲突
var X变量仅声明于函数内部在函数外部不起作用，但在全局函数内部var X变量在函数外部起作用
let X变量声明于全局函数内部时在外部不起作用

1.6 10:31
This是JavaScript内一个巨大的设计错误，需要apply（或call）指定this的指向，或使用=>（箭头函数）然后即可调用this
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空

1.6 14：28
sort()方法默认把所有元素先转换为String再排序
sort()方法会直接对Array进行修改

1.6 16:03
JavaScript的月份范围用整数表示是0~11，0表示一月，1表示二月，所以要表示6月，我们传入的是5！
